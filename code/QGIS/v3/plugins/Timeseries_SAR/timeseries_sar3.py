# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TimeSeriesSAR3
								 A QGIS plugin
 Visualize SAR Time Series for QGIS 3
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
							  -------------------
		begin                : 2019-08-18
		git sha              : $Format:%H$
		copyright            : (C) 2019 by Josef Kellndorfer / Earth Big Data LLC
		email                : kitsin@earthbigdata.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os,sys
import matplotlib
if sys.platform.startswith('linux'):
	matplotlib.use("TkAgg")
from matplotlib import pyplot as plt 

import numpy as np
import struct
# import pandas as pd
import datetime
import csv

# from .timeseries_SAR3_helperFunctions import *

### QGIS PLUGIN BUILDER CODE
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant, QDate, QDateTime
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction,QFileDialog
from qgis.gui import QgsMapToolEmitPoint, QgsMessageBar
from qgis.core import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .timeseries_sar3_dialog import TimeSeriesSAR3Dialog
import os.path

from .timeseries_SAR3_helperFunctions import *

class TimeSeriesSAR3:
	"""QGIS Plugin Implementation."""

	def __init__(self, iface):
		"""Constructor.

		:param iface: An interface instance that will be passed to this class
			which provides the hook by which you can manipulate the QGIS
			application at run time.
		:type iface: QgsInterface
		"""
		# Save reference to the QGIS interface
		self.iface = iface
		# initialize plugin directory
		self.plugin_dir = os.path.dirname(__file__)
		# initialize locale
		locale = QSettings().value('locale/userLocale')[0:2]
		locale_path = os.path.join(
			self.plugin_dir,
			'i18n',
			'TimeSeriesSAR3_{}.qm'.format(locale))

		if os.path.exists(locale_path):
			self.translator = QTranslator()
			self.translator.load(locale_path)
			QCoreApplication.installTranslator(self.translator)

		# Create the dialog (after translation) and keep reference
		self.dlg = TimeSeriesSAR3Dialog()
		# File selection
		self.dlg.selectFiles_pushButton.clicked.connect(self.select_files)
		self.dlg.clearSelections_pushButton.clicked.connect(self.clear_selections)

		# Declare instance attributes
		self.actions = []
		self.menu = self.tr(u'&Time Series SAR')

		self.canvas = iface.mapCanvas()
		#print(dir(self.canvas))
		# Check if plugin was started the first time in current QGIS session
		# Must be set in initGui() to survive plugin reloads
		self.first_start = None

		self.vlayer_id = None

		self.x_range = 5
		self.y_range = 5

		self.line = None
		self.line1 = None
		self.line2 = None

		self.geo_crs=QgsCoordinateReferenceSystem()
		self.geo_crs.createFromString("EPSG:4326")

		self.selected_files = []
		self.selected_urls=[]
		self.url_dict={}

		_px = None
		_py = None

		self.marker=['o','o','x','x']
		self.color=['r','b','r','b']

	def tr(self, message):
		"""Get the translation for a string using Qt translation API.

		We implement this ourselves since we do not inherit QObject.

		:param message: String for translation.
		:type message: str, QString

		:returns: Translated version of message.
		:rtype: QString
		"""
		# noinspection PyTypeChecker,PyArgumentList,PyCallByClass
		return QCoreApplication.translate('TimeSeriesSAR3', message)

	def add_action(
		self,
		icon_path,
		text,
		callback,
		enabled_flag=True,
		add_to_menu=True,
		add_to_toolbar=True,
		status_tip=None,
		whats_this=None,
		parent=None):
		"""Add a toolbar icon to the toolbar.

		:param icon_path: Path to the icon for this action. Can be a resource
			path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
		:type icon_path: str

		:param text: Text that should be shown in menu items for this action.
		:type text: str

		:param callback: Function to be called when the action is triggered.
		:type callback: function

		:param enabled_flag: A flag indicating if the action should be enabled
			by default. Defaults to True.
		:type enabled_flag: bool

		:param add_to_menu: Flag indicating whether the action should also
			be added to the menu. Defaults to True.
		:type add_to_menu: bool

		:param add_to_toolbar: Flag indicating whether the action should also
			be added to the toolbar. Defaults to True.
		:type add_to_toolbar: bool

		:param status_tip: Optional text to show in a popup when mouse pointer
			hovers over the action.
		:type status_tip: str

		:param parent: Parent widget for the new action. Defaults None.
		:type parent: QWidget

		:param whats_this: Optional text to show in the status bar when the
			mouse pointer hovers over the action.

		:returns: The action that was created. Note that the action is also
			added to self.actions list.
		:rtype: QAction
		"""

		icon = QIcon(icon_path)
		action = QAction(icon, text, parent)
		action.triggered.connect(callback)
		action.setEnabled(enabled_flag)

		if status_tip is not None:
			action.setStatusTip(status_tip)

		if whats_this is not None:
			action.setWhatsThis(whats_this)

		if add_to_toolbar:
			# Adds plugin icon to Plugins toolbar
			self.iface.addToolBarIcon(action)

		if add_to_menu:
			self.iface.addPluginToRasterMenu(
				self.menu,
				action)

		self.actions.append(action)

		return action

	def initGui(self):
		"""Create the menu entries and toolbar icons inside the QGIS GUI."""

		icon_path = ':/plugins/timeseries_sar3/icon.png'
		self.add_action(
			icon_path,
			text=self.tr(u'TimeSeries SAR'),
			callback=self.run,
			parent=self.iface.mainWindow())

		# will be set False in run()
		self.first_start = True

		# Map Tool√ü
		self.plottool = QgsMapToolEmitPoint(self.canvas)
		#self.plottool.setAction(self.add_action)
		self.plottool.canvasClicked.connect(self.plot)

	def unload(self):
		"""Removes the plugin menu item and icon from QGIS GUI."""
		for action in self.actions:
			self.iface.removePluginRasterMenu(
				self.tr(u'&Time Series SAR'),
				action)
			self.iface.removeToolBarIcon(action)

	def run(self):
		"""Run method that performs all the real work"""

		# Create the dialog with elements (after translation) and keep reference
		# Only create GUI ONCE in callback, so that it will only load when the plugin is started
		if self.first_start == True:
			self.first_start = False

		# Fetch the currently loaded layers
		self.show_layers()

		# show the dialog
		self.dlg.show()
		# Run the dialog event loop
		result = self.dlg.exec_()
		# See if OK was pressed
		if result:

			# Set some parameters selected in the dialog
			self.set_from_dlg()
			# Selected Layers
			self.select_layers()

			# make the url_dict
			self.make_url_dict()

			# set xlim
			self.set_xlim()

			if not self.url_dict:
				self.iface.messageBar().pushCritical ('Error',
						'Select valid layer(s) or file(s)')
				print ('Select valid layer(s) or file(s)')
				return

			self.tool_enabled = True
			self.canvas.setMapTool(self.plottool) 
		else:
			print('No valid selections')

	def show_layers(self):
		layers = QgsProject.instance().layerTreeRoot().findLayers()
		#children()
		# Use a dictionary to keep track of the selected layers
		layer_lookup={}
		for i in layers:
			layer_lookup[i.name()]=i.layer()

		# Clear the contents of the listWidget box from previous runs
		self.dlg.listWidget.clear()
		# Populate the comboBox with names of all the loaded raster layers
		self.dlg.listWidget.addItems([layer.name() for layer in layers if layer.layer().type() == QgsMapLayerType.RasterLayer])
		self.layer_lookup=layer_lookup

	def select_layers(self):
		# Select layers
		for layer in self.dlg.listWidget.selectedItems():
			l = self.layer_lookup[layer.text()]
			self.selected_urls.append(l.source())
		self.selected_urls=list(set(self.selected_urls))

	def select_files(self):
		"""Optionally select files"""
		self.selected_files = QFileDialog.getOpenFileNames(self.dlg,"Select one or more files to open",os.environ['HOME'],"Images (*.tif *.vrt)")[0]
		self.dlg.selectFiles_listWidget.addItems([os.path.basename(i) for i in self.selected_files])
		self.selected_urls+=self.selected_files
		self.selected_urls=list(set(self.selected_urls))

	def clear_selections(self):
		"""Optionally select files"""
		for url in list(self.url_dict.keys()):
			del self.url_dict[url]
		self.url_dict={}
		self.selected_files = []
		self.selected_urls  = []
		self.dlg.selectFiles_listWidget.clear()

	def set_from_dlg(self):
		# Selected dB range to display
		self.dB_low = self.dlg.dB_low.value()
		self.dB_high = self.dlg.dB_high.value()
		# Selected pixel buffers
		self.x_range = self.dlg.pixel_Buffer_X.value()
		self.y_range = self.dlg.pixel_Buffer_Y.value()
		# Selected min and max dates to display
		self.date_start=self.dlg.date_start.date().toPyDate()
		self.date_end=self.dlg.date_end.date().toPyDate()
		self.date_start=datetime.datetime(self.date_start.year,self.date_start.month,self.date_start.day)
		self.date_end=datetime.datetime(self.date_end.year,self.date_end.month,self.date_end.day)
		self.save_points = self.dlg.save_points.isChecked()

	def get_pos_geo(self,pos):
		# Get the map crs and compare to geo_crs to obtain position in geographic coordinates
		map_crs=self.canvas.mapSettings().destinationCrs()
		# Get the position in geo coordinates for the plot header
		if map_crs==self.geo_crs:
			self.pos_geo=pos
		else:
			geo_transform=QgsCoordinateTransform(map_crs,self.geo_crs,QgsProject.instance())
			self.pos_geo=geo_transform.transform(pos)

	def make_url_dict(self):
		for url in self.selected_urls:
			shortname=os.path.basename(url)
			legendname=shortname
			try:
				ds, geotrans, proj, srs, unit, datatype = ReadInfo(url)
				crs=QgsCoordinateReferenceSystem()
				crs.createFromWkt(proj)
				geo_transform=QgsCoordinateTransform(self.geo_crs,crs,QgsProject.instance())
				self.url_dict[url]={\
				'shortname':shortname,\
				'legendname':legendname,\
				'ds':ds,\
				'geotrans':geotrans,\
				'proj':proj,\
				'srs':srs,\
				'crs':crs,\
				'geo_transform':geo_transform,\
				'unit':unit,\
				'datatype':datatype				
				}
				self.get_url_dates(url)
			except Exception as e:
				print(e)

	def get_pos_proj(self,url):
		# Get the projected position
		self.url_dict[url]['pos_proj']=self.url_dict[url]['geo_transform'].transform(self.pos_geo)

	def get_rastercoords_url(self,url):
		# Get the raster coordinates for a point
		# 1. Get the projected coordinates for the url
		self.get_pos_proj(url)
		# 2. Compute the raster locations in pixel/line coordinates from geotrans
		u=self.url_dict[url]
		pixels = u['ds'].RasterXSize
		lines = u['ds'].RasterYSize
		px,py=(u['pos_proj'].x(),u['pos_proj'].y())
		geo=u['geotrans']
		rx = int(round((px - geo[0]) / geo[1]))
		ry = int(round((py - geo[3]) / geo[5]))
		rx_off = int(round(rx - self.x_range/2))
		ry_off = int(round(ry - self.y_range/2))

		self.url_dict[url]['pos_raster']=(rx,ry)
		# 3. Check for valid raster range given the buffers of x_range/y_range
		self.url_dict[url]['valid_rastercoordinates']=True
		if rx_off < 0 or ry_off < 0:
			self.url_dict[url]['valid_rastercoordinates']=False
		if rx_off + self.x_range > pixels or ry_off + self.y_range > lines:
			self.url_dict[url]['valid_rastercoordinates']=False
		if self.url_dict[url]['valid_rastercoordinates']:
			self.url_dict[url]['raster_subset']=(int(rx_off),int(ry_off),int(self.x_range),int(self.y_range))
			# 4. Get the bounding box in projected coordinates
			bulx=geo[0] + rx_off*geo[1]
			buly=geo[3] + ry_off*geo[5]
			blrx=bulx   + self.x_range*geo[1]
			blry=buly   + self.y_range*geo[5]
			self.url_dict[url]['bbox_ullr']=(bulx,buly,blrx,blry)

	def get_url_dates(self,url):
		# Get the dates in a data set
		ds = self.url_dict[url]['ds']
		dates = dates_from_meta(ds)

		if not dates:
			# read dates file
			fdates=os.path.splitext(url)[0]+'.dates'
			with open(fdates, 'r') as d:
				dates = d.readlines()

		datearr=[s.strip('\n') for s in dates]
		# mydate=pd.to_datetime(datearr)
		mydate=[datetime.datetime.strptime(x,'%Y%m%d') for x in datearr]
		self.url_dict[url]['dates']=mydate

	def get_url_data(self,url):
		# Extract raster data 
		ds = self.url_dict[url]['ds']
		datatype=self.url_dict[url]['datatype']
		raster_subset=self.url_dict[url]['raster_subset']
		nbands = ds.RasterCount
		imgbuf = ds.ReadRaster(*raster_subset)
		bfsize = self.x_range*self.y_range
		if datatype==1:
			myvals = struct.unpack('B'*nbands*bfsize,imgbuf)
		elif datatype==2:
			try:
				myvals = struct.unpack('H'*nbands*bfsize,imgbuf)
			except:
				print('imbuf size{}'.format(imgbuf.shape))
		elif datatype==3:
			try:
				myvals = struct.unpack('h'*nbands*bfsize,imgbuf)
			except:
				print('imbuf size{}'.format(imgbuf.shape))
		elif datatype==6:
			try:
				myvals = struct.unpack('f'*nbands*bfsize,imgbuf)
			except:
				print('imbuf size{}'.format(imgbuf.shape))
		mvalsarr = np.asarray(myvals)
		mv = mvalsarr.reshape(nbands,bfsize)

		# CONVERT TO pwr from DN ( datatype 1 = 8 bit input or AMP ( datatype 2 = 16bit input)
		if datatype==1:
			_,mvpwr = DN2pwr(mv,sf)
		elif datatype == 2:
			_,mvpwr = amp2pwr(mv,0)
		elif datatype == 3:
			_,mvpwr = amp2pwr(mv,0)
		elif datatype == 4:
			mvpwr = mv
		else:
			mvpwr = mv
		mymean = mvpwr.mean(axis=1)
		_,mydB = pwr2dB(mymean)
		self.url_dict[url]['data_dB'] =mydB
		self.url_dict[url]['data_pwr']=mymean

	def set_xlim(self):
		# Set x axis limits
		# If date_start and date_end are not the default values, set the limits to these
		# else, set to min/max of all the found dates in the url_dict:
		default_start=datetime.datetime(2000,1,1)
		default_end=datetime.datetime(2050,12,31)
		# Get min/max date from url_dict
		min_date=default_end
		max_date=default_start
		for url in self.url_dict:
			dates=self.url_dict[url]['dates']
			if min(dates) < min_date: min_date=min(dates)
			if max(dates) > max_date: max_date=max(dates)

		xlim=[None,None]
		xlim[0] = min_date if self.date_start == default_start else self.date_start
		xlim[1] = max_date if self.date_end == default_end else self.date_end
		xlim.sort() # Just in case ...
		self.xlim=tuple(xlim)

	def set_xlabels_xticks(self):
		alldates_datetime=[]
		for url in self.url_dict:
			alldates_datetime+=self.url_dict[url]['dates']
		alldates_datetime=self.alldates
		alldates_datetime = list(set(alldates_datetime))
		alldates_datetime.sort()
		alllabels=['%4d-%02d-%02d' % (i.year,i.month,i.day) for i in alldates_datetime]
		labels_index=[]
		for i in range(len(alldates_datetime)):
			if alldates_datetime[i]>=self.xlim[0] and alldates_datetime[i]<=self.xlim[1]:
				labels_index.append(i)
		self.xlabels=[alllabels[i] for i in labels_index]
		self.xticks =[alldates_datetime[i] for i in labels_index]

	def plot(self, pos):
		"""Data extraction and plotting call"""

		# Set up the plot figure
		if not plt.fignum_exists(1):
			plt.figure()
		else:
			plt.cla()

		self.get_pos_geo(pos)

		url=list(self.url_dict.keys())[0]
		geo=self.url_dict[url]['geotrans']
		proj=self.url_dict[url]['proj']
		self.show_click(pos, geo, proj, self.x_range, self.y_range)
		# Loop over the url_dict to extract values and dates for each layer at the buffered point location display
		i=0
		j=0
		self.line=[]
		self.alldates=[]
		for url in self.url_dict:
			# Get pos in url crs
			self.get_rastercoords_url(url)
			# print(self.url_dict[url])

			# Fetch data if inside raster 
			if not self.url_dict[url]['valid_rastercoordinates']:
				pass 
			else:
				self.get_url_data(url)
				dates=self.url_dict[url]['dates']
				data =self.url_dict[url]['data_dB'] 
				# Filter for nodata
				mask=np.isfinite(data)
				dates2 = list(np.array(dates)[mask])
				self.alldates+=dates2
				data2 = list(np.array(data)[mask])

				tmpplt, = plt.plot(dates2, data2, self.color[i%4],marker=self.marker[i%4])
				self.line.append(tmpplt)  
				self.line[j].axes.set_ylim(self.dB_low, self.dB_high)
				self.line[j].set_label(self.url_dict[url]['legendname'])
				if self.save_points:
					self.save_output(self.pos_geo,data,dates,self.url_dict[url]['shortname'])
				i+=1
				j+=1  
		self.alldates=list(set(self.alldates))
		self.alldates.sort()
		self.set_xlabels_xticks()
		plt.xlim(*self.xlim)

		# plt.yticks(range(-30, 1, 5), fontsize=18)
		plt.yticks(range(self.dB_low, self.dB_high, 5), fontsize=14)
		plt.ylabel('$\gamma^0$ [dB]',fontsize=14)
		plt.xticks(self.xticks,self.xlabels, rotation=30,ha='right',fontsize=9)
		# Title line based on projection or geographic coordinate system of layer
		# Use from the last url added
		u=self.url_dict[url]
		geo=int(u['crs'].authid().split(':')[1])==4326

		if geo:
			plt.title("Lon/Lat {:.5f} {:.5f} - Raster P/L {} {}".format(self.pos_geo.x(),self.pos_geo.y(),u['pos_raster'][0],u['pos_raster'][1]),fontsize=18)
		else:
			# print(u['pos_raster'][0],u['pos_raster'][1])
			plt.title("Lon/Lat {:.5f} {:.5f} - {} X/Y {:.1f} {:.1f} - Raster P/L {} {}".format(self.pos_geo.x(),self.pos_geo.y(),u['crs'].authid(),u['pos_proj'].x(),u['pos_proj'].y(),u['pos_raster'][0],u['pos_raster'][1]),fontsize=18)
		plt.legend()
		plt.grid()
		plt.show()
		plt.draw()

	def show_click(self, pos, gt, projection, x_range, y_range):
		"""
		Receives QgsPoint and adds vector boundary of raster pixel clicked
		"""

		# Get raster pixel px py for pos
		px = int(round((pos[0] - gt[0]) / gt[1]))
		py = int(round((pos[1] - gt[3]) / gt[5]))

		# Upper left coordinates of the pixel 
		ulx = (gt[0] + px * gt[1] + py * gt[2])
		uly = (gt[3] + px * gt[4] + py * gt[5])

		# Upper left coordinates of the buffer around the pixel
		b_ulx = ulx - int(x_range/2) * gt[1]
		b_uly = uly - int(y_range/2) * gt[5]

		# Creat Geometry
		gSquare = QgsGeometry.fromPolygonXY([[
			QgsPointXY(b_ulx, b_uly), # uper left
			QgsPointXY(b_ulx + gt[1]*x_range, b_uly), # upper right
			QgsPointXY(b_ulx + gt[1]*x_range, b_uly + gt[5]*y_range), # lower right
			QgsPointXY(b_ulx, b_uly + gt[5]*y_range) # lower left
			]])


		if self.vlayer_id is not None:
			# Update the vector layer to new clicked pixel
			try:
				vlayer =  QgsProject.instance().mapLayers()[self.vlayer_id]
				vlayer.startEditing()
				pr = vlayer.dataProvider()
				attrs = pr.attributeIndexes()
				for feat in vlayer.getFeatures():
					vlayer.changeAttributeValue(feat.id(), 0, py)
					vlayer.changeAttributeValue(feat.id(), 1, px)
					vlayer.changeGeometry(feat.id(), gSquare)
					vlayer.updateExtents()
				vlayer.commitChanges()
				vlayer.triggerRepaint()
			except Exception as e:
				print(e)
				self.vlayer_id=None
		else:
			# Create vector layer for clicked pixel
			uri = 'polygon?crs=%s' % projection
			vlayer = QgsVectorLayer(uri, 'Query', 'memory')
			pr = vlayer.dataProvider()
			vlayer.startEditing()
			pr.addAttributes( [ QgsField('row', QVariant.Int),
								QgsField('col', QVariant.Int) ] ) 
			feat = QgsFeature()
			feat.setGeometry(gSquare)
			feat.setAttributes([py, px])
			pr.addFeatures([feat])
			# Symbology
			# Reference:
			# http://lists.osgeo.org/pipermail/qgis-developer/2011-April/013772.html
			props = { 'color_border'   : '255, 0, 0, 255',
					  'color'          : '255, 0, 0, 255',
					  'style'          : 'dense7',
					  'style_border'   : 'solid',
					  'width'          : '3'}

			s = QgsFillSymbol.createSimple(props)
			vlayer.setRenderer(QgsSingleSymbolRenderer(s))

			# Commit and add

			vlayer.commitChanges()
			vlayer.updateExtents()

			self.vlayer_id = QgsProject.instance().addMapLayer(vlayer).id()

	def save_output(self, pos, mydB, datearr, image):
		outarr=[pos[0], pos[1]]
		outarr.extend(mydB)
		header=['Lon', 'Lat']
		header.extend(datearr)

		outname=os.path.basename(image)
		outbase=os.path.splitext(outname)[0]
		outdir=os.path.join(os.environ['HOME'],'geo_logs')
		if not os.path.exists(outdir): os.makedirs(outdir)
		outfile=os.path.join(outdir,outbase+'_ts_points.csv')
		if os.path.isfile(outfile):
			openflag='a'
		else:
			openflag='w'
		with open(outfile, openflag) as f:
			wf=csv.writer(f)                 
			if openflag=='w':
				wf.writerow(header)
			wf.writerow(outarr)
				 
